<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE article [
    <!ENTITY R "raphaël">
    <!ENTITY RM "raphaëlMarkup">
    
    <!ENTITY RMBASE "http://cancerbero.vacau.com/raphaelmarkup">
      
]>
<!-- <!ENTITY RMBASE "http://localhost:8081/rm"> -->
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>&RM; User Guide</title>

    <author>
      <personname><firstname>Sebastián</firstname><surname>Gurin</surname></personname>

      <affiliation>
        <orgname>softpoint</orgname>
      </affiliation>
    </author>

    <pubdate>06-17-2010</pubdate>
  </info>
  
  <abstract><para>&RM; User Guide and Reference</para></abstract>
   
  <revhistory>  
    <revision>
      <revnumber>0.01</revnumber>
      <date>20 March 2012</date>
      <authorinitials>sgurin</authorinitials>
      <revremark>Initial revision and release with only some sections</revremark>
    </revision>
  
  </revhistory>
  
   <section id="sec-about-this-document">
    <title>About this document</title>
  	<para>This document is available in the following formats:</para>  
  	<orderedlist>    
	  <listitem><formalpara><title>pdf</title><para>
	  <ulink url="../rm-user-guide-pdf/rm-user-guide.pdf">&RM; User Guide</ulink></para></formalpara></listitem>
	  
	  <listitem><formalpara><title>html fragmented</title><para>
	  <ulink url="../rm-user-guide-htmls/t1.html">&RM; User Guide</ulink></para></formalpara></listitem>
	  
	    <listitem><formalpara><title>html all in one </title><para>
	  <ulink url="../rm-user-guide-html/rm-user-guide.html">&RM; User Guide</ulink></para></formalpara></listitem>
	  
	  
	  <listitem><formalpara><title>docbook (sources) </title><para>
	  <ulink url="../rm-user-guide.xml">&RM; User Guide</ulink></para></formalpara></listitem>
	  
	  <listitem><formalpara><title>download htmls</title><para>
	  <ulink url="../rm-user-guide-htmls.tgz">&RM; User Guide</ulink></para></formalpara></listitem>
  
  	</orderedlist>
  </section>
  
  
  <section id="sec-introduction">
    <title >Introduction</title>

    <para>In this section we will try to explain what is &RM;. </para>
    
    <para><ulink url="http://rapaheljs.com">&R;</ulink> is a portable and easy to use javascript library for vector drawing.
    This project, <ulink url="http://code.google.com/p/raphaelmarkup">&RM;</ulink> 
    brings &R; API to XML, so users can "do &R; drawing" in XML.</para>
    
    <para>This means that &RM; defines a XML syntax for &R; API and implements a 
    javascript engine for rendering XML Documents in raphael </para>    
    
    <mediaobject>
    <imageobject> <imagedata fileref="img/rm1.png" format="PNG"/> </imageobject>
    <textobject> <phrase>first look at raphaelmarkup as a component</phrase> </textobject>
    </mediaobject>
    
    <para>&RM; can be divided in two main sections. First, the core part that define and implement a base &R; XML API. 
    It also implements a simple xml preproccessing and raphael shape post rendering extension mechanism. </para>
    <para>The sencond part is called EXT because the are a bunch of CORE EXTENSIONS 
    that perform some job before XML proccess (preproccessing) or after raphael shape rendering (postrendering). </para>    
    
    <para>While the core module peovide simple base and definition for shape rendering from XML the extensions 
    module provide very usefull utilities and API support, like 
    1) animation XML definition and usage tools, 2) CSS styles for shapes, 3) templates javascript, 
    4) relative bounds, 5) script and events, etc.
    So the following is a more elaborated perspective view of &RM; :  </para>
    
    <mediaobject>
    <imageobject> <imagedata fileref="img/rm2.png" format="PNG"/> </imageobject>
    <textobject> <phrase>complete look at raphaelmarkup as a component</phrase> </textobject>
    </mediaobject>
    
    
    
  </section>
  
   
   
   
   <section><title>Getting started</title>
   
   <para>So do you want to draw webpages using XML? Let's get some fun with &RM;. First
   download latest version from 
   <ulink url="code.google.com/p/raphaelmarkup/">&RM; project site</ulink>. 
   </para>
   
   <para>From all the files inside the .zip you will only need src/rm.js, 
   src/deps/jquery-1.7.1.js and src/deps/raphael-min.js. Of courcse you 
   can use your own raphaeljs or jquery files. </para>
   
   <note><para>If you want a non minified version of the library, 
   then include "src/rm-core.js" and "src/rm-ext.js" (in that order) intead "src/rm.js". </para></note>
   
   <para>So lets write our first html web page with a XML drawing inside: </para>
   
   <programlisting>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
	&lt;script src="jquery-1.7.1.js">&lt;/script>
	&lt;script src="raphael-min.js">&lt;/script>
	&lt;script type="text/javascript" src="rm.js">&lt;/script>
&lt;title>Raphael markup test 1&lt;/title>
&lt;/head>
&lt;body>

&lt;raphael xmlns="http://raphaeljs.com">	
	&lt;paper class="paper1" x="10" y="10" width="400" height="400">
		&lt;rect id="rect1" x="20" y="30" width="100" 
			height="200" fill="red">&lt;/rect>
	&lt;/paper>	
&lt;/raphael>


&lt;script type="text/javascript">
/* render all raphaels elements in this document */
rm.render();
&lt;/script>

&lt;/body>
&lt;/html>
   
   </programlisting>
   
   
   <para>Ok so this first html web page will draw a red rectangle that we 
   defined inside our &lt;raphael> tag. Also, at the end of the html 
   document, a &lt;script> call the javascript renderer to render 
   that drawing in the page. Notice also how at the beggining we included the three 
   neccesary scripts, jquery, raphael and rm.js.</para>
   
   </section>
   
   
   
   
   
   
   <section><title>&R; XML Document</title>
   
    <para>Why &R; in XML ?  Basically we want to use XML and friend technologies for drawing 
    with &R; and accessing and manipulating existing &R; objects with XML tools. In a browser XML format is
    specially usefull because is easy to load and transverse. For example, in the case of &RM; tools like jQuery provide
    portable platform for XML proccessing and DOM manipulation.</para>
    
    <para></para>
    
    <para>Let's compare raphael javascript vs. the equivalent XML markup (a markup that when rendered will perform a similar result). </para>
    
    <programlisting>
var paper = Raphael(0,0,400,400);
var rect = paper.rect(20,20,40,50);
rect.attr({"fill": "red", "stroke": "blue"});
    </programlisting>
    
    <para>Now let see the XML counterpart: </para>
    
    <programlisting>
    
&lt;raphael xmlns="http://raphaeljs.com">
	&lt;paper x="0" y="0" width="400" height="400">
		&lt;rect x="0" y ="0" width="950" height="200" fill="red" stroke="blue">&lt;/rect>
	&lt;/paper>	
&lt;/raphael>

    </programlisting>
    
    <para>Now some notes about the &R; XML Document. 
    containing shapes. </para>
    
    <itemizedlist>
    <listitem>
    <formalpara><title>&R; document</title>
    <para>In general, a &RM; document is a XML &lt;raphael> 
    tag with one or more papers. These papers contains different kind of 
    shapes elements like &lt;rect> &lt;path> &lt;circle>, etc. </para></formalpara>
    </listitem>
    
    <listitem>
    <formalpara><title>Attributes. </title>
    <para>Element attributes correspond to raphael attributes. Also, all elements 
    support attributes "id" and "class" so we can   
   	 use transverse the dom using CSS like selectors, for example, using jquery for 
   	 selecting only certain shapes $("#set1 .button>rect").attr("")</para></formalpara>
    </listitem>
    
    <listitem>
    <formalpara><title>Elements</title>
    <para>Each element correspond to a raphael concept, like a paper, shape, set, 
    etc. Specially in XML, sets gain importance because they act as a DOM 
    container</para></formalpara>
    </listitem>
    
     <listitem>
    <formalpara><title></title>
    <para></para></formalpara>
    </listitem>
    </itemizedlist>
    
    
    
   </section>
   
   
     
  <section id="raphael-tags">
  
    <title>&R; elements</title>
    <para>In this section we will describe &R; related tags. These are what we 
    use for drawing text, path, shapes and images. 
     </para>
        
        
    
    <section><title>raphael</title>
    
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_raphael">this element  XML reference. </ulink>. </para>
    
    <para>It is the main document tag. a valid &RM; document consist in a single &lt;raphael> tag. It contains papers, animations., styles, etc. 
   this element do not contain more attributes than id and class. 
    </para>
    </section>
    
    
    
    <section><title>paper</title>
    
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_paper">this element  XML reference. </ulink>. </para>
    
    <para>Defines a new paper, that is, where the shapes are. Paper is the root shape container. Its dimension and position must be defined. Example 1
    : defining a paper that will be showed at 20,30 with size 400,400: </para>
    
    <programlisting>
	&lt;paper x="20" y="30" width="400" height="400">
	...
	&lt;/paper>
    </programlisting>
    
    <para>Also as in &R; we can render the paper inside an HTML element: </para>
    
     <programlisting>
	&lt;paper x="20" y="30" width="400" height="400" containerEl="">
	...
	&lt;/paper>
    </programlisting>
    
    
    
    </section>
    
    <section><title>shape rect</title><para></para></section>
    
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_rect">this element XML reference. </ulink>. </para>
    
    <section><title>shape circle</title>
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_circle">this element XML reference. </ulink>. </para>
    <para></para>
    </section>
    
    
    <section><title>shape path</title
    ><para></para>
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_path">this element XML reference. </ulink>. </para>
    </section>
    
    <section><title>shape ellipse</title>
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_ellipse">this element XML reference. </ulink>. </para>
    <para></para></section>  
      
    <section><title>shape text</title><para></para>
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_text">this element XML reference. </ulink>. </para>
    </section>
    
    <section><title>shape print</title>
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_print">this element XML reference. </ulink>. </para>
    <para></para></section>
    
    <section><title>set</title>
    <para>See <ulink url="&RMBASE;/src/doc/raphael.xsd.html#element_set">this element XML reference. </ulink>. </para>
    <para>In &R; a set is an artificial shape that "contains" other elements in the sence that if an attribute is set to 
    the set, all "children " elements will be affected as well. In XML Markup, sets are specially usefull for grouping and using CSS selectors on them.
    Sets contain other sets or shapes. See <xref linkend="exts-percentual"/> on how sets can affect bounds of children elements.</para>
    </section>

  </section>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   <section id="sec-extensions">
    <title >Extensions</title>
	<para>In this section we will document each extension specifics.</para>
	<para>TODO: Explain exactly what extensions are - preproccesing - postrendering </para>
	
	
	
	
    <section>
    <title>CSS style</title>
    <para>Since we are working with XML DOM we spect to define styles of elements nusing CSS for 
    setting selectors attribute values. 
    &RM; include a extension for doing this that will parse CSS like code </para>
    
    <para>
    It is important to know that current CSS like support is not CSS. Some CSS language rules are not 
    supported or differet than CSS. For example CSS selector deepths. The main difference is no selector depth
    is respected: a CSS sentence will always overwrite previus selected elements.
	</para>
	
	<para>
    Another big firreference is that &lt;set> childrens (the only &R; box) ) won't inherith parent's style. </para>
    
    </section>
    
    
      
    <section id="exts-template">
    <title>Templates</title>
    <para>&RM; supports the concept of templates. You can define a template, for example, a cool 
    button, panel or whatever and then reuse that component any time you want in your XML. More, you can define 
    input parameters for these componentes, like color, size, etc, and then pass the values in the template-calling. </para>
    
    <para>In &RM; working with templates are divided in two parts, first defining the template in XML, and second, using 
    that template in some parts of your XML code. 
    </para>
    
    <para>We define the templates using the &lt;template tag declaring template parameters and the template body, that is what the template do.
    The template scripting languag supported is javascript. If you know a server page technology like JSP (java server pages) 
    or php, you will see that &RM; templates are similar. It is based on 
    <ulink url="http://ejohn.org/blog/javascript-micro-templating/">John Resig's idea for JavaScript Micro-Templating</ulink>. </para>
    
    <para>The following is a &RM; document that define a template for drawing ellipse buttons. It also containa paper 
    with some shapes and ellipse buttons. Please read that define a button in a template, so
    we can usa that template for defining multiple buttons. </para>
    
    <programlisting>
&lt;?xml version="1.0" encoding="ISO-8859-1"?>
&lt;raphael xmlns="http://raphaeljs.com"

&lt;template name="ellipseButton">

	&lt;!-- with use-tag we can define a custom xml tag for use 
		calling this template -->
	&lt;use-tag name="ellipse-button">&lt;/use-tag>

	&lt;!-- The following are template parameter declarations and are optional, 
		here we put it for informative purposes and for default values -->
		
	&lt;template-arg name="onclick" value="alert('clicked')">&lt;/template-arg>
	&lt;template-arg name="x" value="100">&lt;/template-arg>
	&lt;template-arg name="y" value="100">&lt;/template-arg>
	&lt;template-arg name="rx" value="10">&lt;/template-arg>	
	&lt;template-arg name="ry" value="10">&lt;/template-arg>
	&lt;template-arg name="fill" value="red">&lt;/template-arg>
	&lt;template-arg name="color" value="black">&lt;/template-arg>
	&lt;template-arg name="text" value="black">&lt;/template-arg>		

	&lt;!-- The template body is where we write the markup of the template. 
		In this case we build the ellipse button usng a set with an 
		ellipse and a text. Notice how we evaluate parameter values 
		using {%= %} -->
	&lt;template-body>
		&lt;set class="ellipseButton button">
			&lt;ellipse x="{%= x %}" y="{%= y %}" rx="{%= rx %}" ry="{%= ry %}" 
				fill="{%= fill %}" onclick="{%= onclick%}"					
				onhoverin="rm.getShape(this).attr('fill', 'brown')"
				onhoverout="rm.getShape(this).attr('fill', '{%= fill %}')"
			>&lt;/ellipse>
			&lt;text color="{%= color %}" x="{%= x %}" y="{%= y %}" 
				onclick="{%= onclick%}" font-size="{%= size%}"
				onhoverin="rm.getShape(this.prev()).attr('fill', 'brown')"
				onhoverout="rm.getShape(this.prev()).attr('fill', '{%= fill %}')"
			>{%= text%}&lt;/text>
		&lt;/set>
	&lt;/template-body>
	
&lt;/template>

&lt;!-- Now a paper  with two ellipse buttons -->

&lt;paper x="10" y="100" width="600" height="600">

	&lt;ellipse-button x="120" y="100" rx="80" ry="21" text="Hello" size="20"
		onclick="myapp.openSection('#section1PaperEl')">
	&lt;/ellipse-button>
		
	&lt;ellipse-button x="320" y="190" rx="80" ry="21" color="blue"
		text="world" size="40"
		onclick="myapp.openSection('#section1PaperEl')">
	&lt;/ellipse-button>
			
&lt;/paper>

&lt;/raphael>
    </programlisting>
    
    <para>You can open an html with this example 
    <ulink src="&RMBASE;/src/test/examples/templatingTest2.html">here. </ulink>
    </para>
    
    <para>The most important part is the template's body definition (what's inside &lt;template-body>)
    and how parameters passed by template caller can be accessed there for drawing it. for example, the template code
    <code>&lt;text color="{%= color %}"</code> will be translated to <code>&lt;text color="blue"</code> in the
    template calling <code>&lt; ellipse-button .. color="blue"...></code>. </para>
    
    <para>More importantly is that we are allowed to execute any javascript and even do control flow 
    with javascript (just like java scriptlets in JSPs). </para> 
    
    <para>An interesting thing to notice is that we choose the XML tag "ellipse-button" at template definition using
    <code>&lt;use-tag name="ellipse-button">&lt;/use-tag></code> and then in the paper's we 
    use that XML tag for ǎlling the template. This allows to enrich current &RM; markup with drawing specific dialects. 
    Nevertheless, using custom xml tags is optional, and one can call any template using <code>&lt;template-use></code>. </para>
    
    
    <para>The following example works on this two things. It contains a template that 
    draw a complex entity formed by many small circles drawed and painted randomly. This example use a javascript <code>for()</code>
    loop to create many circle shapes. 
    <ulink src="&RMBASE;/src/test/examples/templatingTest1.html">here. </ulink></para>
    
    <programlisting>

&lt;raphael>
	
&lt;template name="strange1">

	&lt;use-tag name="strange1">&lt;/use-tag>
	
	&lt;!-- parameters: -->
	&lt;template-arg name="cx" value="100">&lt;/template-arg>	
	&lt;template-arg name="cy" value="100">&lt;/template-arg>
	&lt;template-arg name="size" value="100">&lt;/template-arg>
	&lt;template-arg name="circleCount" value="10">&lt;/template-arg>	
	&lt;template-arg name="circleMaxRadius" value="10">&lt;/template-arg>	
	
	&lt;!-- this is the hard part of the template definition:
	1) First of all, all template parameters will be of type string,
	so we may need to cast them to numbers.
	2) Inside a scriptlet {% .. %} we must scape all &lt; and &amp;, for example in 
	"for(var i=0; i&lt;circleCount; i++) {"-->
	&lt;template-body>
		&lt;set class="strange1">
			{%
			circleCount=parseInt(circleCount);
			size=parseInt(size);
			circleMaxRadius=parseInt(circleMaxRadius);
			cx=parseInt(cx);
			cy=parseInt(cy);
			for(var i=0; i&amp;lt;circleCount; i++) { %}
				&lt;circle cx="{%= cx+rm.randomBetween(-size/2, size/2)%}"
					cy="{%= cy+rm.randomBetween(-size/2, size/2)%}"
					fill="{%=rm.randomColor()%}"
					r="{%=rm.randomBetween(2, circleMaxRadius)%}"
					stroke-width="2" stroke="{%=rm.randomColor()%}">&lt;/circle>
			{%}%}	
		&lt;/set>
	&lt;/template-body>
&lt;/template>

&lt;!-- now deifne the paper with some shapes and then use our template: -->

&lt;paper x="10" y="100" width="600" height="600">

	&lt;rect x="20" y="30" width="100" height="200">&lt;/rect>
	&lt;rect x="200" y="30" width="100" height="200">&lt;/rect>
	&lt;circle cx="20" cy="300" radius="20" stroke="red">&lt;/circle>
	
	&lt;set class="set1">
		&lt;circle cx="220" cy="300" radius="40" stroke="red">&lt;/circle>
		&lt;rect x="333" y="130" width="20" height="40">&lt;/rect>
		&lt;ellipse x="333" y="330" rx="20" ry="40">&lt;/ellipse>
	&lt;/set>
	
	&lt;!-- now call our template -->
	&lt;template-use id="strangeShape1" name="strange1">
		&lt;template-arg name="cx" value="100">&lt;/template-arg>
		&lt;template-arg name="cy" value="100">&lt;/template-arg>
		&lt;template-arg name="size" value="140">&lt;/template-arg>
		&lt;template-arg name="circleCount" value="150">&lt;/template-arg>
		&lt;template-arg name="circleMaxRadius" value="8">&lt;/template-arg>		
	&lt;/template-use>
	
	&lt;template-use id="strangeShape2" name="strange1">
		&lt;template-arg name="cx" value="300">&lt;/template-arg>
		&lt;template-arg name="cy" value="200">&lt;/template-arg>
		&lt;template-arg name="size" value="100">&lt;/template-arg>
		&lt;template-arg name="circleCount" value="80">&lt;/template-arg>
		&lt;template-arg name="circleMaxRadius" value="8">&lt;/template-arg>		
	&lt;/template-use>
	
&lt;!-- 	&lt;use also support a short syntax using attributes. But be carefull using this,  -->
&lt;!-- 	because you cannot name your parameters "id", "class" or "name" -->
	&lt;template-use class="strange1Class1" name="strange1" 
		cx="150" cy="320" size="160" circleCount="78" circleMaxRadius="50">&lt;/template-use>
		
		
		or use the tag defined with use-tag eleent in template definition:
	&lt;strange1 class="strange1Class1" name="strange1" 
		cx="250" cy="220" size="160" circleCount="78" circleMaxRadius="50">&lt;/strange1>
&lt;/paper>
&lt;/raphael>

    </programlisting>
    
    
    
    <section><title>Template language</title>
    
    <para>Here are some notes about this template language, that is the template definition inside the template-body tag. </para>
    
    <formalpara><title>Printing</title><para>You can print any javascript evaluated expression using the keywords 
    	<code>{%= %}</code>. For example 
    	<code>
    	&lt;p>Current year is: {%= new Date().getFullYear() =}. &lt;/p>
    	</code>
    	
    	will be translated to 
    	
    	<code>
    	&lt;p>Current year is 2012. &lt;/p>
    	</code>
    	
    	
    	</para></formalpara>
    
    <formalpara><title>Executing</title>
    <para>The most usefull thing about templates is that you can do any javascript you want, even call another 
    javascript framework to perform some neccessary calculationf to print &R; shapes as desired. </para>
    
    <important><para>Inside a scriptlet <code>{% .. %}</code> we must scape all &amp;lt; and &amp;amp;, for example in 
	<code>for(var i=0; i&amp;lt;circleCount; i++) {</code>. For minimizing risk it is recommended that you use as little 
	javascript code as possible insidethe template body. Instead try to put the javascript code in your page's scripts (loaded in head). This can reduce template 
	rendering time in pages with lots of templates, 
	</para></important>
	</formalpara>
    
    <formalpara><title>Parameter types</title><para>The important thing about parameters is that by default they all are strings, so
    perhaps it is required to parse them as numbers in case of numerical calculations (like in the second example). </para>
    
    <para>Nevertheless, you can declare a parameter type so you can spect the desired parameter value type in the template body. 
    For example, in our previus example, in template "strange1" body's we needed to cast some parameters to numbers at body's beggining, 
    because we need numbers for calculations, and we have done it like this:
    </para>
    
    <programlisting>
&lt;template-body>
	&lt;set class="strange1">
		{%
		circleCount=parseInt(circleCount);
		size=parseInt(size);
		....
    </programlisting>
    <para>But we can save that work declaring the type of the parameter in the &lt;template-arg> tag, int this case of type "int". 
    Then we can spect numbers inside our body, so no cast is needed. 
    In the following example we show how to do this; compare to prevois "strange2" template definition:"  
    </para>
    
    <programlisting>

&lt;template name="strange1">
	&lt;use-tag name="strange1">&lt;/use-tag>
	
	&lt;template-arg name="cx" value="100" type="int">&lt;/template-arg>
	&lt;template-arg name="cy" value="100" type="int">&lt;/template-arg>
	&lt;template-arg name="size" value="100" type="int">&lt;/template-arg>
	&lt;template-arg name="circleCount" value="10" type="int">&lt;/template-arg>	
	&lt;template-arg name="circleMaxRadius" value="10" type="int">&lt;/template-arg>	
	
	&lt;template-body>
		&lt;set class="strange1">
			{%
			for(var i=0; i&amp;lt;circleCount; i++) { %}
				&lt;circle cx="{%= cx+rm.randomBetween(-size/2, size/2)%}"
					cy="{%= cy+rm.randomBetween(-size/2, size/2)%}"
					fill="{%=rm.randomColor()%}"
					r="{%=rm.randomBetween(2, circleMaxRadius)%}"
					stroke-width="2" stroke="{%=rm.randomColor()%}">&lt;/circle>
			{%}%}	
		&lt;/set>
	&lt;/template-body>
&lt;/template>
    </programlisting>
    
    <para>This example is available online <ulink url="&RMBASE;/src/test/examples/templatingTest3.html">here</ulink>. </para>
    <para>Current supported types are "int" for integers and "float" for floating point numbers. </para>
    
    </formalpara>
    
	
    </section>
    
    <section><title>Other features</title>
    <formalpara><title>Variables</title><para>In a template, you can define variables using "template-var" element like template-arg:</para>
    <programlisting>
&lt;template>
&lt;template-var name="var1" value="123"/>
&lt;template-body>
&lt;text>var1={%= var1%}&lt;/text>
&lt;/template-body>
&lt;/template>
    </programlisting>
    <para>Like template parameters, variables are suceptible of having a type. </para>
    </formalpara>
    
    
    
    <formalpara><title>Custom tag</title>
    
    <para>As we have seen in the first example, we can use &lt;use-tag> element for defining a custom tag
    for calling our template. In the example, in the tempalte definition we declared 
    <code>&lt;use-tag name="ellipse-button">&lt;/use-tag></code> and then in the paper we just 
    have to call 
    <code>&lt;ellipse-button x="22" y="33" ...>&lt;/ellipse-button></code>. </para>
    
    <para>But as we have seen in second example, cusom xml tags are optional, and we can use 
    <code>&lt;template-use name="ellipse-button"</code> for calling our template. </para>
    
    <important><para>Be careful with elements names. Do not use any html element tag name, and try to be specific, like &lt;myproduct-element1>. </para></important>
    
    </formalpara>
    
    
    
    <formalpara><title>Passing attributes</title>. When you call a template wither with template-use or using its 
    custom tag, all calling element attribute will be copied to the generated (first) element. 
    
    For example, in the case of the ellipse-button
    if I call the template like this <code>&lt;ellipse-button ... id="button1"...>&lt;/ellipse-button></code>, the first 
    generated element in the template, in this case the &lt;set, will have the id "button1" 
    (<code>&lt;set id="button1"..>&lt;/set></code>). This is the case of all attributes except "class". 
    In the case of class, the template-call element's classes will be added to target classes instead of replace them. For example, in the next drawing:</formalpara>
    
    <programlisting>
...
&lt;template>
	&lt;template-body>
	&lt;text class="class1">hello&lt;/text>
	&lt;/template-body>
&lt;/template>
...
&lt;paper...>
	..   
	&lt;ellipse-button ... class="class2"...>
	&lt;/ellipse-button>
&lt;/paper>
...
   	</programlisting>
    <para>the generated shape in the ellipse-button calling will be <code>&lt;text class="class1 class2">hello&lt;/text></code>. 
    This desition is meant to facilitate things when stylizing template generated shapes. 
    So in CSS we can reffere both to the class defined in the template cvlalling element and in the tempalte body elements. </para>
    
    
    <formalpara><title>How this work</title>
    
    <para>At XML preproccessing we perform two tasks. First get all &lt;template and compile each one, for fast rendering. 
    Second all &lt;template-use> elements are evaluated and replaced in the dom with the result of evaluate the template 
    using the parameters provided by the user in the template-calling tag. As simple as that.... :-$ </para>
    
    </formalpara>
    <formalpara><title>Parameters</title><para></para></formalpara>
	
    </section>
    
    
    </section>
    
    
    
    
    
    
    
    
    
    
    
    <section><title>Events</title>
    
    
    <para>The events extension provide support for writing events handler functions in XML attributes onclick, etc just like 
    in html code. All &R; events are supported. </para>    
    
    <para>In the event handler code, the <code>this</code> keyword points to the DOM object that generates the event.
    The shape correspongding to that DOM node can be obtained using 
    <code>rm.getShape(this)</code>.  
    Also the variable <code>event</code> is passed with the mouse event generated. </para>
    
    <para>In the following example we register a click handler 
    in a rectangle and show the user the click's coordinates:</para>
    
    <programlisting>
&lt;rect  x="330" y="350" width="100" height="100" fill="red"
	onclick="alert('click coords: '+event.clientX+','+event.clientY)">
&lt;/rect>
    </programlisting>
    
    <para>Now the same rectangle but changin colors on hovering (make it red with mouse enters and make it yellow when mouse leave):</para>
    
    <programlisting>
&lt;rect  x="330" y="350" width="100" height="100" fill="red"
	onhoverin="rm.getShape(this).attr('fill', 'yellow')"
	onhoverout="rm.getShape(this).attr('fill', 'red')">
&lt;/rect>
    </programlisting>
        
    <para>Some of them are separated in two or more handlers. For
    example, &R; support the function <code>hover(hoverIn, hoverOut)</code> for registering both hover-in and hover-out events. 
    In &RM; we separate this in two event attributes <code>onhoverin</code> and <code>onhoverout</code>. 
    The same happens with ondrag event that is divided in three event attributes <code>ondragstart, ondragend, ondragmove</code>. 
    As in &R; in the case of these advanced handlers, event information is passed to handlers with the same names defined in &R; 
    reference. For example, the ondragmove handler will pass mouse position and dx, dy and this information can be 
    used for moving a shape. For example, this is a classic shape dragging code: </para>
    
    <programlisting>
&lt;rect  x="330" y="350" width="100" height="100" 
	radius="10" fill="red"
	ondragmove="rm.getShape(this).transform('t'+dx+','+dy)">
&lt;/rect>
    </programlisting>
    
    <para>In <xref linkend="exts-animation"/> we will se other event example for animating a shape after the user clicks it.</para>
    
    </section>
    








    <section id="exts-animation"><title>Animations</title>
    <para>The animation extension provide support for two things 1) be able to define animations in XML and 
    2) provide utilities for easy animation calling using javascript from eventshandlers and other js code.</para>
    
    <para>In the following example source code, we show how easily is to call an animation defined in xml from an event handler: </para>
    <programlisting>
    
&lt;raphael>
&lt;animation id="textglowing1">	
	&lt;scene ellapse="0%" fill="black">&lt;/scene>
	&lt;scene ellapse="33%" transform="S1.5" easing="easy-in">&lt;/scene>
	&lt;scene ellapse="66%" transform="...s0.6 r33" easing="easy-out">&lt;/scene>
	&lt;scene ellapse="100%" transform="S1.0 R0" fill="red" easing="elastic">&lt;/scene>
&lt;/animation>

&lt;paper x="0" y="0" width="950" height="1000">
	&lt;rect  x="330" y="350" width="100" height="100"
		fill="url(imgs/lblue018.gif)"
		onhoverin="rm.animate(this, 'textglowing1', 3000)"
		>
	&lt;/rect>
&lt;/paper>
&lt;/raphael>
    </programlisting>
    
    <para>As you can see we made two things, first define an entire animation and name 
    it "textglowing1", using the &lt;animation> tag. Second, 
    easily use that animation for animating a shape when it is clicked.
    In this case we call <code>rm.animate()</code> for calling the animation once, but we can an animation with a delay or a re</para>
    
    <itemizedlist>
    
    <listitem><formalpara><title>rm.animate()</title>
    <para>Call <code>rm.animate(this, anim1, animMs)</code> for animate this shape with animation anim1 </para></formalpara></listitem>
    
    <listitem><formalpara><title>rm.delay()</title>
    <para>Call <code>rm.repeat(this, anim1, animMs, delayMs)</code> for applying animation anim1 with duration animMs milisecond and with a delay time of delayMs miliseconds. </para></formalpara></listitem>
    
    <listitem><formalpara><title>rm.repeat()</title>
    <para>Call <code>rm.repeat(this, anim1, animMs, repeatTimes)</code> for applying an animation anim1 
    repeatead animTimes number of timesm each time dutin animMs miliseconds.  </para></formalpara></listitem>
    
    </itemizedlist>
    
    <para>Also, animation extension provide for easy invoking defined animations 
    from javascript, f</para>
    </section>
	
	
	
	
	
	
	
	
	
	
	<section><title>script</title>
	<para>A &lt;script> tag just like html's is supported for putting (javascript) scripts inside
	&RM; markup. </para>
	</section>
	
	
	
	
	
	
	
	
	<section><title>include</title>
	
	<para>&RM; supports an include tag that can be used to include a markup in other file to current document. 
	File content is reading dynamicaly using an ajax request. This is not a &RM; extension but a core mechanism available for 
	include other file contents before any preproccessing is done at all.</para>
	
	<para>The included .xml document must in the document element tag <code>&lt;rm-include></code>, for example, for putting all your page templates in a separate .xml file you do it content like this: </para>
	
	<programlisting>
&lt;?xml version="1.0" encoding="ISO-8859-1"?>

&lt;rm-include>

&lt;template name="templ1Name">
...
&lt;/template>
...

&lt;/rm-include>
	</programlisting>
	
	<para>&lt;include only support one level of inclusion. For example, if you 
	include a document that includes another document it won't work. </para>
	
	<para>It is not recommended to use &lt;include> intensively; if you can 
	use templates and don't use include. </para>
	
	</section>
	
	
	
	
	
	
	
	
	
	 <section id="exts-percentual">
	 <title>Percentual bounds</title>
	 
	 <para>&RM; comes with an extension that let specify a shape's dimension and 
	 position in relative coordinates. If a dimension/position attribute 
	 values ends with '%' it is precalculated according to its parent dimension/position. 
	 To shapes that do not support bounding attrs, like set and path, x, y, width, and height 
	 artificila attributes can be used. In the case of a set, you can assign a set a 
	 absolute or percentual position/size, and its children can 
	 spcify relative bounding attributes like x="80%" or height="20%" and they will 
	 be preproccessed relative to set's base..</para>
	 
	 
	 <programlisting>	 	 
	 Example: the following markup: 
	 
&lt;paper x="0" y="0" width="400" height="400">	
	&lt;set class="set1" x="80%" y="80%" width="20%" height="20%">
		&lt;rect x="0%" y="0%" width="100%" height="100%" fill="blue">&lt;/rect>
		&lt;text x="50%" y="50%">blue rectangle bottom-left &lt;/text>		
	&lt;/set>	
&lt;/paper>

Will be translated to the following markup at preproccessing

&lt;paper x="0" y="0" width="400" height="400">	
	&lt;set class="set1" x="10%" y="10%" width="20%" height="20%">
		&lt;rect x="40" y="40" width="80" height="80" fill="blue">&lt;/rect>
		&lt;text x="200" y="200">blue rectangle bottom-left &lt;/text>		
	&lt;/set>	
&lt;/paper>
	 </programlisting>
	 
	 
	 <para>This extension does two things: </para>
	 <para>1) at preproccessing, it calculate the real position and sizes of shapes 
	 with "%" attributes. Since a paper must have non percentual dimensions, this can be calculated at 
	 preproccessing only using the dom. </para>
	 
	 <para>2) in post rendering, transform paths translate and scaling them to feet x,y,width and height specified attributes. 
	 In the case of paths, only position and width will work. Paths are special. The other base raphael 
	 shapes like rects, circles, ellipses all have bounding attrinbutes like x, y, cx, cy, width, height, rx, 
	 ry, radious. But path hasn't, because the bounds of the shape is defined by the shape 
	 string itself. This extension adds support for path, x, y, and width attributes that can be percentual or 
	 not, but if specified, will force a path to translate/scale to fit specified x,y,width (apppending 
	 transformation at postrendering.)</para>
	 <para>in the case of print will be the same as paths</para>
	 <para>In the case of text only position will work.</para>
	 
	 </section>
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <section id="exts-textwrapp"><title>Text Wrapping</title>
	 <para>&RM; comes with an extension that adds support for text wrapping. If you specify a <code>width</code>
	 attribute to any &lt;text> the framework will add the neccessary new line characters to wrpp the text to the specified width, for example</para>
	 
	 <programlisting>
&lt;text x="100" y="200" width="200" fill="blue" font-size="17px">
	A very long long text
&lt;/text>
	 </programlisting>
	 
	 <para>Of course, you can take advantge of percentual bounds extensions, documented in <xref linkend="exts-percentual"/>,
	 for specify a perentual width. </para>
	 </section>
	 
	 
	 
	 
	 
	 <section id="exts-tofrontback">
	 <title>toFront and toBack attributes. </title>
	 <para>&RM; comes with an extension that adds support for text wrapping. If you specify a <code>width</code>
	 attribute to any &lt;text> the framework will add the neccessary new line characters to wrpp the text to the specified width, for example</para>
	 
	 <programlisting>
&lt;text x="100" y="200" width="200" fill="blue" font-size="17px">
	A very long long text
&lt;/text>
	 </programlisting>
	 
	 <para>Of course, you can take advantge of percentual bounds extensions, documented in <xref linkend="exts-percentual"/>,
	 for specify a perentual width. </para>
	 </section>
	 
	 
	  <section id="exts-zindex"><title>z-index</title>
	 <para>Similar than toFront/toBack extension, &RM; also support the <code>z-index</code>
	 attribute, similar to CSS z-index. In the following example, we draw two rects, the blue should be on front, 
	 but because we set a z-index to the first, the red one is on the front</para>
	 
	 <programlisting>
&lt;rect x="50" y="50" width="160" height="160" fill="red" z-index="1">&lt;/rect>
&lt;rect x="110" y="110" width="260" height="120" fill="blue">&lt;/rect>
	 </programlisting>
	 
	 <para>Also, notice that if you set a z-index to a &lt;set> then all its children will inherith that z-index. 
	 int the following example, we add a set with a little green rect that, because it is first on the markup it 
	 should be covered by other shapes, but because we use a z-index=2 it is seen: </para>
	 
	 <programlisting>
&lt;!-- this set elements (little green rect) should be covered by other shapes, but because we use a z-index=2 it is seen.-->
&lt;set z-index="2">
&lt;rect x="70" y="70" width="40" height="30" fill="green">&lt;/rect>
&lt;/set>

&lt;!-- two rects, the blue should be on front, but because we set a z-index to the first, the red one is on the front.  -->

&lt;rect x="50" y="50" width="70" height="60" fill="red" z-index="1">&lt;/rect>
&lt;rect x="80" y="80" width="60" height="80" fill="blue">&lt;/rect>
	 </programlisting>
	 
	 <para>This exact example can be opened <ulink url="&RMBASE;/src/test/examples/zindexTest1.html">here. </ulink></para>
	 
	 </section>
	 
	 
	 
	 <section><title>Blur</title>
	 <para>&RM;support apply a blur effect over any shape, you only have to use the attribute blur="1". 
	 The higher the number the more blurred the object will appear. </para>
	 
	 </section>
	 
  </section>
  
  
  
  
  
  
  
  
  
  
  
  <section><title>Using &RM; in a web page</title>
  
  <para>This document try to explain different ways of including your raphael markup drawing in html documents. </para>
  
  
    
  
  <section><title>Embedding in HTML</title>
  
  <para>The most simple way of putting your &R; drawing in your html web pages
  is putting the &lt;raphael> element in the same html file, toghether with the rest of the html code.
  </para>
  
  <para>An example on how to do that is 
  <ulink url="&RMBASE;/src/test/raphaeltest2.html">here</ulink>. The next is an extract with that example source's with explaining comments: 
  </para>
  
  <programlisting>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
	&lt;script src="../deps/jquery-1.7.1.js">&lt;/script>
	&lt;script src="../deps/raphael-min.js">&lt;/script>
	&lt;script type="text/javascript" src="../rm.js">&lt;/script>
&lt;/head>
&lt;body>

&lt;!-- our HTML will be formed by two things, a &lt;raphael> element with a 
drawing inside and a script calling &RM; framework for rendering that drawing -->

&lt;raphael xmlns="http://raphaeljs.com">	
	&lt;paper class="paperclass1" x="10" y="10" width="400" height="400">
		&lt;rect x="20" y="30" width="100" height="200" id="rect1">&lt;/rect>
		&lt;rect x="200" y="30" width="100" height="200">&lt;/rect>
		....
	&lt;/paper>	
&lt;/raphael>


&lt;script type="text/javascript">
/* render all raphaels elements in this document */
rm.render();
&lt;/script>
&lt;/body>
&lt;/html>
  
  </programlisting>
  
  <para>Important things to notice in the code are 1) include of 3 javascript files: jquery, raphael and &RM;. 
  2) the &lt;raphael element just inside the html document's &lt;body>
  3) at last, a javascript call to the framework to render all &lt;raphael> elements found in the HTMl document.</para>
  	
<note><para>For portability reasons is important that the &lt;raphael> elements declaration contains the <code>xmlns="http://raphaeljs.com"</code> attribute 
exactly like in the example. </para></note>

  <para></para>
  <para></para>
    
  </section>
  
  
  
  
  <section><title>Loading XML a la AJAX</title>
  <para>&RM;support XML document asynchronous loading. This is the recomended way. Basically you put your XML 
  document in a different XML document, and in your HTML file ask the framework to load it.  
  </para>
  
  <para>In the following example we show a HTML source loading a XML drawing like this. <ulink url="&RMBASE;/src/test/raphaeltest_ajax.html">See example demo here. </ulink></para>
  
  <programlisting>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
	&lt;script src="../deps/jquery-1.7.1.js">&lt;/script>
	&lt;script src="../deps/raphael-min.js">&lt;/script>
	&lt;script type="text/javascript" src="../rm.js">&lt;/script>
&lt;/head>
&lt;body>

&lt;script type="text/javascript">
/* render the xml document drawing1.xml. The document must be in the same server. */
rm.renderAjax("drawing1.xml", function (rdoc) {
	/* rdoc is a ready to use jquery DOM object with our xml dom inside. 
		we can access it for querying or even manipulate it: */
	alert("the document has "+rdoc.find("rect")+" rectangles.");
});
&lt;/script>

&lt;/body>
&lt;/html>

  </programlisting>
  
  <para>And the loaded drawing1.xml file:</para>
  
  <programlisting>
&lt;raphael>
	&lt;paper x="10" y="10" width="400" height="400">
		&lt;rect x="20" y="30" width="100" height="200"/>
		...
	&lt;/paper>
&lt;/raphael>
  </programlisting>
  
  </section>
  
  
  
  
  
  
  <section><title>Render the XML file directly using XSL stylesheet</title>
  
  <para>You can present your XMl drawing documents directly using a XSL 
  (XML stylesheet) provided by the framework. For example, 
  <ulink url="&RMBASE;/src/test/xsltest1/drawing1.xml">this drawing link</ulink> points to a XML file linking the 
  framework XSL stylesheet. If you opened with a modern browser 
  it should show you the drawing. (no HTML code needed at all!). The important thing is
  including a xsl stylesheet called drawing1.xml using the following:  
   </para> 

<programlisting>
&lt;?xml-stylesheet type="text/xsl" href="drawing1.xsl"?>
</programlisting>

<para>We must also write the configuration XSL file drawing1.xsl that must contain some information, like the path to dependency javascripts (jquery, raphael, etc), the title of the html document, and the path of the raphael.xsl, the main raphael markup XSL file for transforming a .xml docuemnt with our drawing into an xhtml document viewable by the browser. So create drawing1.xsl file in the same folder as drawing1.xml and with a content like this:</para>



<programlisting>
&lt;?xml version="1.0" encoding="ISO-8859-1"?>
&lt;xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">		
	
	&lt;!-- please fix the following variables and paths -->
	&lt;xsl:variable name="doc.title" select="'raphael markup test1'" />
	&lt;xsl:variable name="raphael.id" select="'raphaelDocument1'" />	
	&lt;xsl:variable name="raphael.js.path" select="'../../deps/raphael-min.js'" />
	&lt;xsl:variable name="jquery.js.path" select="'../../deps/jquery-1.7.1.min.js'" />
	&lt;xsl:variable name="rm.js.path" select="'../../rm.js'" />
	&lt;xsl:include href="../../raphael.xsl"/> 	
	
	&lt;xsl:template match="*">
	&lt;/xsl:template>
&lt;/xsl:stylesheet>
</programlisting>

<important><para>this only works in firefox and chrome and it is important, in the xml file to define the 
&lt;raphael> element just without ANY attributes, like in the demo. 
For this to work on IE the &lt;raphael> element must be defined like this:
</para>

<programlisting>
&lt;raphael xmlns="http://raphaeljs.com">
</programlisting>

</important>
 
   <note><para>This metodology for showing a XML drawing is not recommended to use 
   in production because it is not fully tested yet-do not work in IE). It is more a prove of concept 
   that a XML &RM;drawing XML stylesheet could be easily made using &RM; framework.</para></note>
   
   
  </section>
  
  </section>
  
  
  
  
  
  
  
  <section><title>Integration</title>
  
  <para>&RM; is designed to be integrated in a number of ways. It not only serves for drawing in XML but also
  export and load data from different format and sources, load a native &R; javascript paper object to a XML DOM
  for reading/modifying and later re-render the original paper for updating changes. In this section we will disccuss 
  this and other related scenarios. </para>
  
  
  <section><title>Accessing a &R; native paper with &RM; XML API</title>   
  <para>&RM; support loading of any raphael paper into an XML DOM object. This XML DOM object can then be transversed using XML 
  utilities like CSS3 selectors. Then if you make modifications to the dom, you can re-render them in other paper or update the original.
  Since &RM; avocates for a more intensive use of sets for declaring element parentship, with that in mind, accessing a paper with some 
  structure given by sets is sometimes more convenient to do in XML than in javascript with raphaeljs api.</para> 
  <para>In the following example we show how to load a &RM; drawing from an existing paper.</para></section>
  
   
  <section><title>Reading and writing XML</title>
  <para></para></section>
  
  
  <section><title>Reading and writing JSON</title>
  <para>&R; library support exporting and importing data in JSON format. For example
  <ulink url="http://raphaeljs.com/reference.html#Paper.add"><code>paper.add()</code>
  will add all the shapes defined in a json string into a paper. In the &R; world json format seems to be the
  preffered way of storing raphael drawings, for example, <ulink url="">Charles SVG to Raphaël converter</ulink>
  can convert SVG into &R; JSON format, </ulink></para>
  
  <para>&RM; support importing this kind of JSON data. There is an example showing just this 
  <ulink url="$RMBASE;/src/test/examples/jsonTest1.html">here. </ulink></para>
  
  </section>
  
   
  
  </section>
  
</article>
